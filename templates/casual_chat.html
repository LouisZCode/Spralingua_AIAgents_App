{% extends "base.html" %}

{% block title %}Casual Conversation Practice - Spralingua{% endblock %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/casual_chat.css') }}?v={{ timestamp }}">
<style>
    /* Updated voice controls layout for microphone + send button */
    .voice-only-wrapper {
        position: relative;
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .voice-only-controls {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        justify-content: center;
        align-items: center;
        padding: 1rem;
    }
    
    .btn-voice-large {
        width: 80px;
        height: 80px;
        font-size: 2rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white !important;
        border: none;
        z-index: 10;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .btn-voice-large:hover {
        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        color: white !important;
        transform: scale(1.05);
    }
    
    #send-btn {
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
        transition: all 0.3s ease;
        margin-top: 0.5rem;
    }
    
    #send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    #send-btn:not(:disabled):hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    /* =================== Timed Recording UI Styles (from GTA-V2) =================== */
    
    .timed-recording-container {
        position: relative;
        padding: 2rem;
        background: linear-gradient(135deg, #ff6b6b 0%, #ff8787 100%);
        border-radius: 12px;
        text-align: center;
        animation: pulse-recording 2s ease-in-out infinite;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1.5rem;
        box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
    }
    
    /* Circular timer styles */
    .timed-recording-container.circular-style .circular-timer {
        position: relative;
        width: 120px;
        height: 120px;
        margin: 0 auto;
    }
    
    .circular-timer svg {
        transform: rotate(-90deg);
        width: 100%;
        height: 100%;
    }
    
    .timer-circle-progress {
        transition: stroke-dashoffset 0.1s linear;
    }
    
    .timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 28px;
        font-weight: bold;
        color: white;
        font-family: 'Inter', -apple-system, sans-serif;
    }
    
    /* Recording status */
    .recording-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: white;
        font-size: 16px;
        opacity: 0.95;
    }
    
    .recording-dot {
        width: 12px;
        height: 12px;
        background: white;
        border-radius: 50%;
        animation: recording-blink 1.5s ease-in-out infinite;
    }
    
    .recording-label {
        font-weight: 500;
    }
    
    /* Stop button */
    .stop-recording-button {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 12px 24px;
        background: white;
        color: #ff6b6b;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .stop-recording-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        background: #f8f9fa;
    }
    
    .stop-recording-button:active {
        transform: translateY(0);
    }
    
    /* Disabled state for stop button */
    .stop-recording-button:disabled,
    .stop-recording-button[disabled] {
        background: #e0e0e0 !important;
        color: #999 !important;
        cursor: not-allowed !important;
        opacity: 0.6 !important;
        transform: none !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
    }
    
    .stop-recording-button:disabled:hover,
    .stop-recording-button[disabled]:hover {
        background: #e0e0e0 !important;
        transform: none !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
        cursor: not-allowed !important;
    }
    
    .stop-icon {
        font-size: 20px;
    }
    
    /* Animations */
    @keyframes pulse-recording {
        0% {
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
        }
        50% {
            box-shadow: 0 4px 30px rgba(255, 107, 107, 0.5);
        }
        100% {
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
        }
    }
    
    @keyframes recording-blink {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: 0.3;
        }
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
        .timed-recording-container {
            padding: 1.5rem;
            min-height: 180px;
        }
        
        .circular-timer {
            width: 100px;
            height: 100px;
        }
        
        .timer-text {
            font-size: 24px;
        }
        
        .stop-recording-button {
            padding: 10px 20px;
            font-size: 14px;
        }
    }
</style>
{% endblock %}

{% block content %}
    <!-- Welcome Screen Overlay -->
    <div id="welcome-overlay" class="welcome-overlay">
        <div class="welcome-content">
            <h1 class="welcome-title" data-translate="casual_conversation_practice">Casual Conversation Practice</h1>
            <p class="welcome-subtitle" data-translate="practice_everyday">Practice everyday conversations in a relaxed setting. Let's chat about daily life, hobbies, and interests!</p>
            <button id="start-btn" class="btn-start" data-translate="start_chatting">
                Start Chatting
            </button>
        </div>
    </div>
    
    <!-- Character Selection Overlay -->
    <div id="character-selection-overlay" class="character-selection-overlay" style="display: none;">
        <div class="character-selection-content">
            <h2 class="selection-title" data-translate="choose_partner">Choose Your Conversation Partner</h2>
            <p class="selection-subtitle" data-translate="select_practice_today">Select who you'd like to practice with today:</p>
            
            <div class="character-grid">
                <!-- Harry Card -->
                <div class="character-card" data-character="harry">
                    <div class="character-preview">
                        <div class="character-placeholder">
                            <span class="placeholder-emoji">üèÇ</span>
                        </div>
                    </div>
                    <h3 class="character-name">Happy Harry</h3>
                    <p class="character-description" data-translate="harry_description">Cheerful snowboard instructor who loves parties and sports</p>
                    <button class="select-character-btn" data-translate="chat_with_harry">Chat with Harry</button>
                </div>
                
                <!-- Sally Card -->
                <div class="character-card" data-character="sally">
                    <div class="character-preview">
                        <div class="character-placeholder">
                            <span class="placeholder-emoji">üìö</span>
                        </div>
                    </div>
                    <h3 class="character-name">Sad Sally</h3>
                    <p class="character-description" data-translate="sally_description">Thoughtful librarian who finds beauty in melancholy</p>
                    <button class="select-character-btn" data-translate="chat_with_sally">Chat with Sally</button>
                </div>
            </div>
            
            <!-- Random Selection Button -->
            <div class="random-selection">
                <button id="random-character-btn" class="btn-random">
                    üé≤ <span data-translate="surprise_me">Surprise Me!</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Back Navigation -->
    <div class="back-nav-container" id="back-nav" style="display: none;">
        <a href="{{ url_for('exercises') }}" class="back-nav-button">
            <span class="back-arrow">‚Üê</span>
            <span data-translate="back_to_exercises">Back to Exercises</span>
        </a>
    </div>

    <!-- Main wrapper to contain chat and feedback vertically -->
    <div class="main-wrapper">
        <div class="chat-container conversation-mode">
            <div class="chat-header">
                <div class="header-title">
                    <h1 data-translate="casual_conversation_practice">Casual Conversation Practice</h1>
                    <p class="instructor-name" data-translate="ai_chat_partner">AI Chat Partner</p>
                    {% if target_language %}
                    <p class="language-indicator" style="color: white; font-size: 0.9em; margin-top: 5px;">
                        üéØ <span data-translate="practicing_label">Practicing:</span> 
                        <span data-translate="lang_{{ target_language }}">{{ target_language|capitalize }}</span>
                    </p>
                    {% endif %}
                </div>
            </div>

            <div class="avatar-section">
                <div id="avatar-container" class="avatar-container">
                    <!-- Lottie animation container -->
                    <div id="avatar-lottie" style="width: 100%; height: 100%; display: none;"></div>
                    
                    <!-- Placeholder shown when no animation is loaded -->
                    <div id="avatar-placeholder" class="avatar-placeholder">
                        <div class="placeholder-icon">üí¨</div>
                        <div class="placeholder-text" data-translate="chat_partner_placeholder">Chat Partner</div>
                    </div>
                </div>
                
                <!-- Volume Control -->
                <div class="volume-control" id="volume-control">
                    <button class="volume-mute-btn" id="volume-mute-btn" title="Mute/Unmute">
                        <span class="volume-icon">üîä</span>
                    </button>
                    <div class="volume-slider-container">
                        <input type="range" class="volume-slider" id="volume-slider" 
                               min="0" max="100" value="70" step="1"
                               orient="vertical" title="Volume">
                        <div class="volume-percentage" id="volume-percentage">70%</div>
                    </div>
                </div>
            </div>
            
            <!-- Progress Bar (below avatar section) -->
            <div class="progress-container" id="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-text" id="progress-text" data-target-language="{{ target_language }}">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <div class="chat-messages" id="chat-messages">
                <div class="message assistant-message" id="scenario-message">
                    <div class="message-content">
                        <!-- Scenario will be set dynamically based on character selection -->
                    </div>
                </div>
            </div>

            <div class="chat-input-container voice-only">
                <!-- Hint container OUTSIDE voice-only-wrapper so it doesn't get destroyed -->
                <div class="inline-hint-container" id="inline-hint" style="display: none;">
                    <div class="inline-hint-content" id="inline-hint-content">
                        <!-- Dynamic hint content will be inserted here -->
                    </div>
                </div>

                <!-- Mobile hint button (also outside) -->
                <button class="mobile-hint-toggle" id="mobile-hint-btn" style="display: none;">
                    üí° <span id="mobile-hint-text">Hint</span>
                </button>

                <div class="voice-only-wrapper">
                    <div class="voice-only-controls input-group">
                        <button type="button" id="voice-btn" class="btn btn-voice btn-voice-large" title="Click to speak">
                            üé§
                        </button>
                    </div>
                </div>
                <!-- Hidden form and input for compatibility -->
                <form id="chat-form" class="chat-form" style="display: none;">
                    <textarea 
                        id="message-input" 
                        class="message-input" 
                        style="display: none;"
                    ></textarea>
                </form>
            </div>
        </div>
        
        <!-- Feedback Panel for Language Learning -->
        <div class="feedback-container" id="feedback-container">
            <div class="feedback-panel hint-panel" id="hint-panel" style="display: none;">
                <div class="feedback-header hint-header">
                    <h4>üí° Language Hint</h4>
                </div>
                <div class="feedback-content hint-content" id="hint-content">
                    <!-- Dynamic hints will be inserted here -->
                </div>
            </div>
            
            <div class="feedback-panel overview-panel" id="overview-panel" style="display: none;">
                <div class="feedback-header overview-header">
                    <h3>üìä Your Progress Overview</h3>
                    <span class="response-count" id="response-count">After 5 responses</span>
                </div>
                <div class="feedback-content overview-content" id="overview-content">
                    <!-- Overview feedback will be inserted here -->
                </div>
            </div>
        </div>
    </div>
    <!-- End of main wrapper -->

    <div id="error-message" class="error-message" style="display: none;">
        <div class="error-content">
            <h3>Connection Error</h3>
            <p>Unable to connect to the server. Please check your internet connection and try again.</p>
            <button id="error-close" class="btn btn-secondary">Close</button>
        </div>
    </div>
{% endblock %}

{% block lottie %}
<!-- Lottie/Bodymovin library for avatar animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>
{% endblock %}

{% block scripts %}
<!-- Define configuration BEFORE loading JS files -->
<script>
    // Configuration objects for voice input/output system - MUST be defined before loading JS files
    window.VOICE_INPUT_CONFIG = {
        language: '{{ speech_code|default("de-DE") }}', // Dynamic language from user's selection
        recording_mode: 'timed',          // Enable timed recording mode
        max_duration: 30000,              // 30 seconds instead of 60
        show_visual_timer: true,          // Show the circular timer
        timer_style: 'circular',          // Visual style of timer
        accumulate_transcript: true,      // Collect all speech segments
        auto_restart_on_silence: true,    // Keep recording during pauses
        stop_button_text: "I'm Done Speaking",  // Will be updated with translation
        recording_label: "Recording...",  // Will be updated with translation
        auto_submit_mode: 'always',       // Auto-submit when done
        show_transcript: false,           // Don't show transcript
        allow_editing: false,             // No editing allowed
        show_transcript_preview: false,   // No preview during recording
        // Manual send button removed - using GTA-V2's simpler approach
        confidence_override: 0.6,         // Slightly lower for natural conversation
        debug: true
    };
    
    // Function to update config with translations
    function updateVoiceConfigTranslations() {
        console.log('[MICROPHONE UI] Attempting to update translations...');
        console.log('[MICROPHONE UI] translationManager exists?', !!window.translationManager);
        console.log('[MICROPHONE UI] VOICE_INPUT_CONFIG exists?', !!window.VOICE_INPUT_CONFIG);
        
        if (window.translationManager && window.VOICE_INPUT_CONFIG) {
            const currentLang = window.translationManager.getCurrentLanguage();
            const storedLang = localStorage.getItem('userLanguage');
            console.log('[MICROPHONE UI] Current language from translationManager:', currentLang);
            console.log('[MICROPHONE UI] localStorage userLanguage:', storedLang);
            
            // Debug: Check if translation exists
            const testDoneSpeaking = window.translationManager.getText('done_speaking');
            const testRecording = window.translationManager.getText('recording_status');
            console.log('[MICROPHONE UI] Test getText("done_speaking"):', testDoneSpeaking);
            console.log('[MICROPHONE UI] Test getText("recording_status"):', testRecording);
            
            // Check the translations object directly
            if (window.translationManager.translations && window.translationManager.translations[currentLang]) {
                console.log('[MICROPHONE UI] Direct translation check:', {
                    done_speaking: window.translationManager.translations[currentLang].done_speaking,
                    recording_status: window.translationManager.translations[currentLang].recording_status
                });
            }
            
            window.VOICE_INPUT_CONFIG.stop_button_text = testDoneSpeaking;
            window.VOICE_INPUT_CONFIG.recording_label = testRecording;
            
            console.log('[MICROPHONE UI] Final config values:', {
                stop_button_text: window.VOICE_INPUT_CONFIG.stop_button_text,
                recording_label: window.VOICE_INPUT_CONFIG.recording_label,
                language: currentLang
            });
        } else {
            console.warn('[MICROPHONE UI] Could not update translations - manager or config not ready');
        }
    }
    
    // Update translations as soon as translationManager is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Small delay to ensure translationManager is initialized
        setTimeout(updateVoiceConfigTranslations, 100);
    });
    
    // Log the configuration to verify it's correct
    console.log('[LANGUAGE CONFIG] Target language: {{ target_language }}');
    console.log('[LANGUAGE CONFIG] Speech recognition code: {{ speech_code }}');
    console.log('[LANGUAGE CONFIG] Target language: {{ target_language }}');
    console.log('[LANGUAGE CONFIG] VOICE_INPUT_CONFIG.language:', window.VOICE_INPUT_CONFIG.language);
</script>

<!-- Load avatar controller for Lottie animations -->
<script src="{{ url_for('static', filename='js/avatar.js') }}?v={{ timestamp }}"></script>
<!-- Load listening-mode.js for blur/reveal feature -->
<script src="{{ url_for('static', filename='js/listening-mode.js') }}?v={{ timestamp }}"></script>
<!-- Load hint display manager for inline hints -->
<script src="{{ url_for('static', filename='js/hint-display.js') }}?v={{ timestamp }}"></script>
<!-- Load timed recording UI for voice input -->
<script src="{{ url_for('static', filename='js/timed-recording-ui.js') }}?v={{ timestamp }}"></script>
<!-- Load chat wrapper for voice input/output integration -->
<script src="{{ url_for('static', filename='js/chat-wrapper.js') }}?v={{ timestamp }}"></script>
<!-- Load voice output system for TTS -->
<script src="{{ url_for('static', filename='js/voice-output.js') }}?v={{ timestamp }}"></script>
<!-- Load voice input system from GTA-V2 -->
<script src="{{ url_for('static', filename='js/voice-input.js') }}?v={{ timestamp }}"></script>

<script>
    // Character Configurations
    const CHARACTERS = {
        harry: {
            id: 'harry',
            name: 'Happy Harry',
            description: 'Cheerful snowboard instructor who loves parties and sports',
            scenario: `placeholder`,
            animations: {
                idle: '/static/animations/harry-idle.json',
                thinking: '/static/animations/harry-thinking.json',
                speaking: '/static/animations/harry-speaking.json',
                listening: '/static/animations/harry-idle.json' // Use idle as fallback
            }
        },
        sally: {
            id: 'sally',
            name: 'Sad Sally',
            description: 'Thoughtful librarian who finds beauty in melancholy',
            scenario: `You're walking through a quiet park in Berlin when you notice Sad Sally sitting on a bench, reading a book. She's the thoughtful librarian from your local library. She looks up and recognizes you with a gentle, melancholic smile.
            
            "Ach, hallo..." she says softly, closing her book. "Sch√∂n dich zu sehen... wie geht's dir denn?"
            
            Start the conversation by greeting her...`,
            animations: {
                idle: '/static/animations/sally-idle.json',
                thinking: '/static/animations/sally-thinking.json',
                speaking: '/static/animations/sally-speaking.json',
                listening: '/static/animations/sally-idle.json' // Use idle as fallback
            }
        }
    };
    
    // Selected character (will be set by selection screen)
    let selectedCharacter = null;
    let listeningModeManager = null; // Will be initialized after character selection
    window.avatarController = null; // Will be initialized after character selection (global for voice system access)
    
    // Message Exchange Display System
    class MessageExchangeDisplay {
        constructor(containerId) {
            this.container = document.getElementById(containerId);
            this.currentExchange = { user: null, assistant: null };
            this.isFirstMessage = true;
            this.useExchangeMode = true; // Can be toggled to fall back to chat mode
        }
        
        showUserMessage(text) {
            // Hide placeholder on first message
            if (this.isFirstMessage) {
                const scenarioMessage = document.getElementById('scenario-message');
                if (scenarioMessage) {
                    scenarioMessage.classList.add('scenario-hidden');
                }
                this.isFirstMessage = false;
            }
            
            // Fade out previous exchange if exists
            if (this.currentExchange.user || this.currentExchange.assistant) {
                this.fadeOutCurrentExchange();
            }
            
            // Wait for fade out to complete, then show new user message
            setTimeout(() => {
                // Clear container
                this.container.innerHTML = '';
                
                // Add container class for centered layout
                this.container.classList.add('message-exchange');
                
                // Create user message
                const userDiv = document.createElement('div');
                userDiv.className = 'message message-centered user-message';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.textContent = text;
                
                userDiv.appendChild(contentDiv);
                this.container.appendChild(userDiv);
                
                this.currentExchange.user = userDiv;
                this.currentExchange.assistant = null;
            }, this.currentExchange.user ? 500 : 0); // Wait for fade if there's previous content
        }
        
        showAssistantMessage(text, useBlur = true, audioPlaying = false) {
            // Create assistant message
            const assistantDiv = document.createElement('div');
            assistantDiv.className = 'message message-centered assistant-message';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = text;
            
            // Apply blur if listening mode is enabled
            if (useBlur && listeningModeManager && listeningModeManager.isEnabled()) {
                assistantDiv.appendChild(contentDiv);
                const messageIndex = 0; // Always 0 since we only show one exchange
                
                // Check if we're in audio-sync mode and audio is playing
                if (audioPlaying && listeningModeManager.config.mode === 'audio-sync') {
                    // Use the delayed button method for audio-sync
                    const blurredWrapper = listeningModeManager.applyBlurWithDelayedButton(contentDiv, messageIndex);
                    assistantDiv.innerHTML = '';
                    assistantDiv.appendChild(blurredWrapper);
                    // Store reference for audio end handler
                    this.pendingRevealWrapper = blurredWrapper;
                } else {
                    // Use standard blur method
                    const blurredWrapper = listeningModeManager.applyBlurToMessage(contentDiv, messageIndex);
                    assistantDiv.innerHTML = '';
                    assistantDiv.appendChild(blurredWrapper);
                }
            } else {
                assistantDiv.appendChild(contentDiv);
            }
            
            this.container.appendChild(assistantDiv);
            this.currentExchange.assistant = assistantDiv;
        }
        
        fadeOutCurrentExchange() {
            // Add fading class to current messages
            if (this.currentExchange.user) {
                this.currentExchange.user.classList.add('message-fading-out');
            }
            if (this.currentExchange.assistant) {
                this.currentExchange.assistant.classList.add('message-fading-out');
            }
        }
        
        isEnabled() {
            return this.useExchangeMode;
        }
        
        toggle() {
            this.useExchangeMode = !this.useExchangeMode;
            return this.useExchangeMode;
        }
    }
    
    // Initialize message exchange display
    let messageExchangeDisplay = null;
    
    // Configuration objects for voice input/output system
    const CHAT_CONFIG = {
        placeholders: {
            default: "Type a message or click the microphone to speak..."
        }
    };
    
    // VOICE_INPUT_CONFIG is now defined at the top of scripts block before JS files are loaded
    
    const LANGUAGE_SELECTOR_CONFIG = {
        currentLanguage: 'de' // Default to German
    };
    
    // Voice output configuration for TTS
    const VOICE_CONFIG = {
        harry: {
            voice_id: 'male-qn-qingse',     // Cheerful male voice
            speed: 1.2,
            pitch: 0,
            volume: 1.0
        },
        sally: {
            voice_id: 'female-shaonv',      // Thoughtful female voice
            speed: 1.0,
            pitch: -2,
            volume: 0.9
        },
        ttsEndpoint: '/api/casual-chat/tts',
        ttsTimeout: 30000,  // 30 seconds timeout
        enableTTS: true      // Can be toggled on/off
    };
    
    // Global variables for voice system
    let chatInterface = null;
    let voiceInput = null;
    
    // Log the language configuration for debugging
    console.log('[LANGUAGE CONFIG] Target language: {{ target_language|default("not set") }}');
    console.log('[LANGUAGE CONFIG] Speech recognition code: {{ speech_code|default("not set") }}');
    console.log('[LANGUAGE CONFIG] Target language: {{ target_language|default("not set") }}');
    
    document.addEventListener('DOMContentLoaded', function() {
        // Handle start button - shows character selection
        const startBtn = document.getElementById('start-btn');
        const welcomeOverlay = document.getElementById('welcome-overlay');
        const characterOverlay = document.getElementById('character-selection-overlay');
        
        startBtn.addEventListener('click', function() {
            welcomeOverlay.style.opacity = '0';
            setTimeout(() => {
                welcomeOverlay.style.display = 'none';
                characterOverlay.style.display = 'flex';
            }, 300);
        });
        
        // Handle character selection
        const characterCards = document.querySelectorAll('.character-card');
        characterCards.forEach(card => {
            card.addEventListener('click', function() {
                const character = this.getAttribute('data-character');
                initializeCharacter(character);
            });
        });
        
        // Handle random character selection
        const randomBtn = document.getElementById('random-character-btn');
        randomBtn.addEventListener('click', function() {
            const characterKeys = Object.keys(CHARACTERS);
            const randomIndex = Math.floor(Math.random() * characterKeys.length);
            const randomCharacter = characterKeys[randomIndex];
            initializeCharacter(randomCharacter);
        });
        
        // Initialize character and show chat interface
        async function initializeCharacter(character) {
            selectedCharacter = CHARACTERS[character];
            console.log(`Selected character: ${selectedCharacter.name}`);
            
            // Clear any existing session first
            try {
                await fetch('/api/casual-chat/clear', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ action: 'clear' })
                });
                console.log('[SESSION] Cleared previous session on character selection');
            } catch (error) {
                console.warn('[SESSION] Could not clear previous session:', error);
            }
            
            // Reset local message counter
            messageCount = 0;
            
            // Reset progress text with correct language
            const progressText = document.getElementById('progress-text');
            if (progressText) {
                const targetLang = progressText.dataset.targetLanguage;
                progressText.textContent = getLocalizedCounterText(0, targetLang);
            }
            
            // Initialize MessageExchangeDisplay for focused conversation view
            messageExchangeDisplay = new MessageExchangeDisplay('chat-messages');
            console.log('MessageExchangeDisplay initialized');
            
            // Initialize ListeningModeManager for blur/reveal feature
            listeningModeManager = new ListeningModeManager({
                enabled: true,
                mode: 'audio-sync', // Show reveal button only after audio ends
                buttonText: 'Read', // Will be localized in showRevealButton
                blurIntensity: 8,
                trackUsage: true
            });
            console.log('ListeningModeManager initialized for', selectedCharacter.name);
            
            // Initialize AvatarController with character-specific animations
            window.avatarController = new AvatarController('avatar-container', selectedCharacter.animations);
            const avatarInitialized = window.avatarController.init('avatar-container');
            console.log(`Avatar initialization for ${selectedCharacter.name}:`, avatarInitialized ? 'SUCCESS' : 'FAILED');
            
            if (avatarInitialized) {
                // Start with idle state
                window.avatarController.setState('idle');
                console.log(`${selectedCharacter.name} avatar set to idle state`);
            }
            
            // Update instructor name
            const instructorName = document.querySelector('.instructor-name');
            if (instructorName) {
                instructorName.textContent = selectedCharacter.name;
            }

            // Fetch and update dynamic scenario
            try {
                const response = await fetch(`/api/casual-chat/scenario?character=${character}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('[SCENARIO] Fetched dynamic scenario:', data);

                    // Update scenario message with dynamic content
                    const scenarioMessage = document.querySelector('#scenario-message .message-content');
                    if (scenarioMessage) {
                        scenarioMessage.textContent = data.scenario || selectedCharacter.scenario;
                    }
                } else {
                    console.warn('[SCENARIO] Could not fetch dynamic scenario, using default');
                    // Fall back to static scenario
                    const scenarioMessage = document.querySelector('#scenario-message .message-content');
                    if (scenarioMessage) {
                        scenarioMessage.textContent = selectedCharacter.scenario;
                    }
                }
            } catch (error) {
                console.error('[SCENARIO] Error fetching scenario:', error);
                // Fall back to static scenario
                const scenarioMessage = document.querySelector('#scenario-message .message-content');
                if (scenarioMessage) {
                    scenarioMessage.textContent = selectedCharacter.scenario;
                }
            }
            
            // Hide character selection overlay
            const characterOverlay = document.getElementById('character-selection-overlay');
            characterOverlay.style.opacity = '0';
            setTimeout(() => {
                characterOverlay.style.display = 'none';
                // Show back button
                const backNav = document.getElementById('back-nav');
                if (backNav) {
                    backNav.style.display = 'block';
                }
                
                // Initialize voice input system after character selection
                initializeVoiceSystem();
                
                // Initialize volume controls after voice system is ready
                setTimeout(() => {
                    initializeVolumeControls();
                }, 800);
            }, 300);
        }
        
        // Initialize voice input system
        function initializeVoiceSystem() {
            console.log('[CASUAL CHAT] Initializing voice system...');
            
            // Wait a bit for DOM to fully update after showing chat interface
            setTimeout(() => {
                // Check if button exists
                const voiceBtn = document.getElementById('voice-btn');
                if (!voiceBtn) {
                    console.error('[CASUAL CHAT] Voice button not found in DOM');
                    return;
                }
                
                console.log('[CASUAL CHAT] Voice button found, initializing voice system');
                
                // Wait for translationManager to be fully ready
                let attempts = 0;
                const maxAttempts = 10;
                const checkTranslationManager = () => {
                    attempts++;
                    console.log(`[CASUAL CHAT] Checking for translationManager (attempt ${attempts}/${maxAttempts})...`);
                    
                    if (window.translationManager) {
                        console.log('[CASUAL CHAT] TranslationManager found! Updating voice config...');
                        // Update translations before creating VoiceInput
                        updateVoiceConfigTranslations();
                        
                        // Continue with initialization
                        initializeVoiceInputAfterTranslations();
                    } else if (attempts < maxAttempts) {
                        setTimeout(checkTranslationManager, 100);
                    } else {
                        console.error('[CASUAL CHAT] TranslationManager not found after 10 attempts');
                        // Continue anyway with English defaults
                        initializeVoiceInputAfterTranslations();
                    }
                };
                
                checkTranslationManager();
                return; // Exit here, will continue in initializeVoiceInputAfterTranslations
            }, 500); // Give DOM time to update
        }
        
        function initializeVoiceInputAfterTranslations() {
            // Initialize ChatInterface wrapper
            chatInterface = new ChatInterface();
            
            // Initialize VoiceInput with just chatInterface (as GTA-V2 expects)
            voiceInput = new VoiceInput(chatInterface);
            
            // Make voiceInput globally accessible for refresh
            window.voiceInput = voiceInput;
            
            console.log('[CASUAL CHAT] Voice system initialized successfully');
        }
        
        // Initialize volume controls for TTS
        function initializeVolumeControls() {
            const volumeSlider = document.getElementById('volume-slider');
            const volumePercentage = document.getElementById('volume-percentage');
            const muteBtn = document.getElementById('volume-mute-btn');
            
            if (!volumeSlider || !muteBtn) {
                console.warn('[VOLUME] Volume controls not found in DOM');
                return;
            }
            
            // Get VoiceOutput instance from global singleton or chat interface
            const voiceOutput = window.voiceOutputInstance || 
                              (chatInterface && chatInterface.voiceOutput);
            if (!voiceOutput) {
                console.warn('[VOLUME] VoiceOutput not initialized yet, retrying...');
                setTimeout(initializeVolumeControls, 500);
                return;
            }
            
            console.log('[VOLUME] Initializing volume controls with singleton instance');
            
            // Set initial slider value from saved preference (direct mapping)
            const savedVolume = voiceOutput.getVolume();
            const volumeValue = Math.round(savedVolume * 100);
            volumeSlider.value = volumeValue;
            volumePercentage.textContent = `${volumeValue}%`;
            
            // Update mute button state
            const updateMuteButton = (isMuted) => {
                const volumeIcon = muteBtn.querySelector('.volume-icon');
                if (volumeIcon) {
                    volumeIcon.textContent = isMuted ? 'üîá' : 'üîä';
                }
                muteBtn.classList.toggle('muted', isMuted);
            };
            
            updateMuteButton(voiceOutput.isMutedState());
            
            // Volume slider event
            volumeSlider.addEventListener('input', function() {
                // Direct mapping: bottom = 0%, top = 100%
                const displayValue = parseInt(this.value);
                const actualVolume = displayValue / 100;
                
                voiceOutput.setVolume(actualVolume);
                volumePercentage.textContent = `${displayValue}%`;
                
                // If unmuted and volume > 0, ensure unmuted
                if (actualVolume > 0 && voiceOutput.isMutedState()) {
                    voiceOutput.toggleMute();
                    updateMuteButton(false);
                }
            });
            
            // Mute button event
            muteBtn.addEventListener('click', function() {
                const isMuted = voiceOutput.toggleMute();
                updateMuteButton(isMuted);
                
                // Visual feedback
                if (isMuted) {
                    volumeSlider.classList.add('muted');
                } else {
                    volumeSlider.classList.remove('muted');
                }
            });
            
            console.log('[VOLUME] Volume controls initialized successfully');
        }
        
        // Helper functions for localized counter text
        function getLocalizedCounterText(count, targetLanguage) {
            // Wait for translationManager to be available
            if (!window.translationManager) {
                // Fallback to English if translation manager not ready
                return `${count}/${totalMessagesRequired} messages sent`;
            }
            
            // Get the template string with placeholders
            const template = window.translationManager.getText('messages_in_language');
            
            // Get localized language name (capitalized)
            const languageName = window.translationManager.getText(`lang_${targetLanguage}`);
            
            // Format with actual values
            return window.translationManager.formatString(template, {
                count: count,
                total: totalMessagesRequired,
                language: languageName
            });
        }
        
        function getLocalizedCompletionText(targetLanguage) {
            // Wait for translationManager to be available
            if (!window.translationManager) {
                // Fallback to English if translation manager not ready
                return 'Conversation complete! Great job!';
            }
            
            const template = window.translationManager.getText('conversation_complete_language');
            const languageName = window.translationManager.getText(`lang_${targetLanguage}`);
            
            return window.translationManager.formatString(template, {
                language: languageName
            });
        }
        
        // Get DOM elements for later use
        const messageInput = document.getElementById('message-input');
        const chatMessages = document.getElementById('chat-messages');
        
        // Function to send message to API (made global for voice input)
        window.sendMessage = async function(message) {
            // Add user message to chat (visual feedback)
            addMessageToChat(message, 'user');
            
            // Update progress bar IMMEDIATELY with local counter
            messageCount++;
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const percentage = (messageCount / totalMessagesRequired) * 100;
            
            progressFill.style.width = `${percentage}%`;
            const targetLang = progressText.dataset.targetLanguage;
            progressText.textContent = getLocalizedCounterText(messageCount, targetLang);
            
            // Check if complete
            if (messageCount >= totalMessagesRequired) {
                progressText.textContent = getLocalizedCompletionText(targetLang);
                document.getElementById('progress-container').classList.add('complete');
                const voiceBtn = document.getElementById('voice-btn');
                if (voiceBtn) {
                    voiceBtn.disabled = true;
                    voiceBtn.innerHTML = '‚úÖ';
                }
            }
            
            // Set avatar to thinking state while waiting for response
            if (window.avatarController && window.avatarController.isReady()) {
                window.avatarController.setState('thinking');
            }
            
            try {
                const response = await fetch('/api/casual-chat/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        character: selectedCharacter ? selectedCharacter.id : 'harry'
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();

                // Update total messages required from backend (dynamic from database)
                if (data.total_messages_required) {
                    totalMessagesRequired = data.total_messages_required;
                    console.log(`[API] Total exchanges required: ${totalMessagesRequired}`);
                }

                // Store response for delayed display (will show when audio starts)
                const assistantResponse = data.response;
                let textDisplayed = false;

                // Store hint immediately if present (before setting up handlers)
                if (data.hint) {
                    console.log('[HINT] Received hint from backend:', data.hint);
                    if (VOICE_CONFIG.enableTTS) {
                        // Store hint to show after audio
                        pendingHint = data.hint;
                        console.log('[HINT] Stored pendingHint for display after audio ends');
                    } else {
                        // No TTS, show hint immediately
                        console.log('[HINT] No TTS, showing hint immediately');
                        showHint(data.hint);
                    }
                }

                // Play TTS if voice output is enabled
                if (VOICE_CONFIG.enableTTS && chatInterface && chatInterface.voiceOutput) {
                    // Set up one-time listener for audio start event
                    const audioStartHandler = (event) => {
                        if (event.detail.state === 'speaking' && !textDisplayed) {
                            // Display text when audio actually starts playing (with audioPlaying=true)
                            addMessageToChat(assistantResponse, 'assistant', true);
                            textDisplayed = true;
                            // Remove listener after displaying text
                            document.removeEventListener('voiceOutputStateChange', audioStartHandler);
                        }
                    };

                    // Set up audio end handler to show the "Read" button and hint
                    const audioEndHandler = (event) => {
                        console.log('[AUDIO END HANDLER] Event received:', event.detail);
                        if (event.detail.state === 'idle') {
                            console.log('[AUDIO END HANDLER] State is idle, processing end actions');

                            // Show the "Read" button when audio ends
                            if (messageExchangeDisplay && messageExchangeDisplay.pendingRevealWrapper) {
                                console.log('[AUDIO END HANDLER] Showing reveal button');
                                listeningModeManager.showRevealButton(messageExchangeDisplay.pendingRevealWrapper);
                                messageExchangeDisplay.pendingRevealWrapper = null;
                            }

                            // Show hint after audio ends (if available)
                            console.log('[AUDIO END HANDLER] Checking for pendingHint:', pendingHint);
                            if (pendingHint) {
                                console.log('[AUDIO END HANDLER] Showing hint');
                                showHint(pendingHint);
                                pendingHint = null;  // Clear pending hint
                            } else {
                                console.log('[AUDIO END HANDLER] No pendingHint to display');
                            }

                            document.removeEventListener('voiceOutputStateChange', audioEndHandler);
                        }
                    };
                    
                    // Add event listeners before starting TTS
                    document.addEventListener('voiceOutputStateChange', audioStartHandler);
                    document.addEventListener('voiceOutputStateChange', audioEndHandler);
                    
                    try {
                        // Configure voice for current character
                        const voiceSettings = VOICE_CONFIG[selectedCharacter.id] || {};
                        window.VOICE_CONFIG = {
                            ...voiceSettings,
                            ttsEndpoint: VOICE_CONFIG.ttsEndpoint,
                            character: selectedCharacter.id
                        };
                        
                        // Play the response with TTS
                        await chatInterface.playAssistantResponse(assistantResponse, selectedCharacter.id);
                        
                        // Cleanup: if text wasn't displayed (e.g., audio failed silently), display it now
                        if (!textDisplayed) {
                            document.removeEventListener('voiceOutputStateChange', audioStartHandler);
                            document.removeEventListener('voiceOutputStateChange', audioEndHandler);
                            addMessageToChat(assistantResponse, 'assistant');
                            textDisplayed = true;
                        }
                    } catch (error) {
                        console.error('TTS playback error:', error);
                        // Remove listeners on error
                        document.removeEventListener('voiceOutputStateChange', audioStartHandler);
                        document.removeEventListener('voiceOutputStateChange', audioEndHandler);
                        
                        // Display text immediately as fallback if not already displayed
                        if (!textDisplayed) {
                            addMessageToChat(assistantResponse, 'assistant');
                            textDisplayed = true;
                        }
                        
                        // Fallback to idle state on error
                        if (window.avatarController && window.avatarController.isReady()) {
                            window.avatarController.setState('idle');
                        }
                    }
                } else {
                    // No TTS enabled, display text immediately
                    addMessageToChat(assistantResponse, 'assistant');
                    
                    // Set avatar to idle
                    if (window.avatarController && window.avatarController.isReady()) {
                        window.avatarController.setState('idle');
                    }
                }
                
                // Note: Progress bar is already updated immediately when message is sent
                // We can use the backend count for validation if needed
                if (data.message_count && data.message_count !== messageCount) {
                    console.warn(`[PROGRESS] Local count (${messageCount}) differs from backend (${data.message_count})`);
                }
                
                // Note: Hint is already handled earlier, before setting up audio handlers
                
                // Show comprehensive feedback if available
                if (data.comprehensive_feedback) {
                    showComprehensiveFeedback(data.comprehensive_feedback, data.message_count);
                }
                
            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message. Please try again.');
            }
        }
        
        // Function to add message to chat display
        function addMessageToChat(message, sender, audioPlaying = false) {
            // Use MessageExchangeDisplay if enabled
            if (messageExchangeDisplay && messageExchangeDisplay.isEnabled()) {
                if (sender === 'user') {
                    messageExchangeDisplay.showUserMessage(message);
                } else if (sender === 'assistant') {
                    messageExchangeDisplay.showAssistantMessage(message, true, audioPlaying);
                }
            } else {
                // Fall back to original chat display
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}-message`;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.textContent = message;
                
                // Apply blur to assistant messages using ListeningModeManager
                if (sender === 'assistant' && listeningModeManager && listeningModeManager.isEnabled()) {
                    // Add content to message div first
                    messageDiv.appendChild(contentDiv);
                    
                    // Apply blur effect and get wrapper with reveal button
                    const messageIndex = chatMessages.querySelectorAll('.assistant-message').length;
                    const blurredWrapper = listeningModeManager.applyBlurToMessage(contentDiv, messageIndex);
                    
                    // Clear the message div and add the blurred wrapper
                    messageDiv.innerHTML = '';
                    messageDiv.appendChild(blurredWrapper);
                    
                    chatMessages.appendChild(messageDiv);
                } else {
                    // Normal message display for user messages or when blur is disabled
                    messageDiv.appendChild(contentDiv);
                    chatMessages.appendChild(messageDiv);
                }
                
                // Scroll to bottom
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }
        
        // Function to show error
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            const errorContent = errorDiv.querySelector('p');
            errorContent.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        // Track progress locally
        let messageCount = 0;
        let totalMessagesRequired = 5;  // Default to 5, will be updated from API
        
        // Store hint data globally for delayed display
        let pendingHint = null;

        // Function to show language hint
        function showHint(hintData) {
            console.log('[SHOW HINT] Function called with:', hintData);

            // Try new inline hint display first
            if (window.hintDisplay) {
                console.log('[SHOW HINT] Attempting to use HintDisplay system');
                if (window.hintDisplay.show(hintData)) {
                    console.log('[HINT] Successfully displayed using new inline system');
                    return;
                } else {
                    console.log('[HINT] HintDisplay.show() returned false');
                }
            } else {
                console.log('[SHOW HINT] window.hintDisplay not available');
            }

            // Fallback to old panel system
            console.log('[SHOW HINT] Using fallback panel system');
            const hintPanel = document.getElementById('hint-panel');
            const hintContent = document.getElementById('hint-content');

            if (hintPanel && hintContent) {
                // Format hint content
                let hintHTML = '';
                if (hintData.phrase) {
                    hintHTML += `<strong>Phrase:</strong> "${hintData.phrase}"<br>`;
                }
                if (hintData.hint) {
                    hintHTML += `<strong>Tip:</strong> ${hintData.hint}`;
                }

                hintContent.innerHTML = hintHTML;
                hintPanel.style.display = 'block';
                console.log('[SHOW HINT] Displayed in fallback panel');
            } else {
                console.log('[SHOW HINT] Fallback panel elements not found');
            }
        }
        
        // Function to show comprehensive feedback
        function showComprehensiveFeedback(feedbackData, messageCount) {
            const overviewPanel = document.getElementById('overview-panel');
            const overviewContent = document.getElementById('overview-content');
            const responseCount = document.getElementById('response-count');

            if (overviewPanel && overviewContent) {
                let feedbackHTML = '';

                // Get translations
                const commonMistakesText = translationManager.getText('feedback_common_mistakes');
                const errorLabelText = translationManager.getText('feedback_error_label');
                const correctionLabelText = translationManager.getText('feedback_correction_label');
                const yourStrengthsText = translationManager.getText('feedback_your_strengths');
                const areasFocusText = translationManager.getText('feedback_areas_focus');
                const overallText = translationManager.getText('feedback_overall');

                // Show top mistakes
                if (feedbackData.top_mistakes && feedbackData.top_mistakes.length > 0) {
                    feedbackHTML += `<div class="feedback-section"><h4>${commonMistakesText}</h4><ul>`;
                    feedbackData.top_mistakes.forEach(mistake => {
                        feedbackHTML += `<li>
                            <strong>${errorLabelText}</strong> "${mistake.error}"<br>
                            <strong>${correctionLabelText}</strong> "${mistake.correction}"<br>
                            <em>${mistake.explanation}</em>
                        </li>`;
                    });
                    feedbackHTML += '</ul></div>';
                }
                
                // Show strengths
                if (feedbackData.strengths && feedbackData.strengths.length > 0) {
                    feedbackHTML += `<div class="feedback-section"><h4>${yourStrengthsText}</h4><ul>`;
                    feedbackData.strengths.forEach(strength => {
                        // Handle both object structure and simple strings for backward compatibility
                        if (typeof strength === 'object' && strength.phrase && strength.praise) {
                            feedbackHTML += `<li><strong>"${strength.phrase}"</strong> - ${strength.praise}</li>`;
                        } else {
                            feedbackHTML += `<li>${strength}</li>`;
                        }
                    });
                    feedbackHTML += '</ul></div>';
                }
                
                // Show focus areas
                if (feedbackData.focus_areas && feedbackData.focus_areas.length > 0) {
                    feedbackHTML += `<div class="feedback-section"><h4>${areasFocusText}</h4><ul>`;
                    feedbackData.focus_areas.forEach(area => {
                        feedbackHTML += `<li>${area}</li>`;
                    });
                    feedbackHTML += '</ul></div>';
                }
                
                // Show overall feedback
                if (feedbackData.overall_feedback) {
                    feedbackHTML += `<div class="feedback-section"><h4>${overallText}</h4><p>${feedbackData.overall_feedback}</p></div>`;
                }
                
                overviewContent.innerHTML = feedbackHTML;
                if (responseCount) {
                    responseCount.textContent = `After ${messageCount} responses`;
                }
                overviewPanel.style.display = 'block';
            }
        }
        
        // Placeholder for volume control
        const volumeSlider = document.getElementById('volume-slider');
        const volumePercentage = document.getElementById('volume-percentage');
        if (volumeSlider && volumePercentage) {
            volumeSlider.addEventListener('input', function() {
                const displayValue = parseInt(this.value);
                volumePercentage.textContent = `${displayValue}%`;
            });
        }
        
        // Error message close button
        const errorClose = document.getElementById('error-close');
        if (errorClose) {
            errorClose.addEventListener('click', function() {
                document.getElementById('error-message').style.display = 'none';
            });
        }
        
        // Session Management: Clear conversation when leaving page
        // This prevents the 6-message counter from persisting between sessions
        window.addEventListener('beforeunload', function() {
            console.log('[SESSION] Clearing casual chat session on page unload');
            
            // Send async request to clear session (fire and forget)
            // Using sendBeacon for reliability during page unload
            if (navigator.sendBeacon) {
                const clearData = JSON.stringify({ action: 'clear' });
                navigator.sendBeacon('/api/casual-chat/clear', new Blob([clearData], {type: 'application/json'}));
            } else {
                // Fallback to fetch (less reliable during unload)
                fetch('/api/casual-chat/clear', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ action: 'clear' }),
                    keepalive: true  // Helps request complete during unload
                }).catch(() => {
                    // Silently fail - page is unloading anyway
                });
            }
        });
        
        // Initialize counter text with correct language on page load
        setTimeout(() => {
            const progressText = document.getElementById('progress-text');
            if (progressText) {
                const targetLang = progressText.dataset.targetLanguage;
                if (targetLang) {
                    progressText.textContent = getLocalizedCounterText(0, targetLang);
                    console.log('[COUNTER] Initialized with language:', targetLang);
                }
            }
        }, 200); // Wait for TranslationManager to be ready
        
        // Also clear when navigating away via back button
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('[SESSION] Page hidden - clearing session for clean state');
                fetch('/api/casual-chat/clear', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ action: 'clear' })
                }).catch(() => {
                    // Silently fail
                });
            }
        });
    });
</script>
{% endblock %}